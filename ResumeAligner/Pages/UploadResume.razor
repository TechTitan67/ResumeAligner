@page "/upload-resume"
@inject HttpClient Http
@inject ProtectedSessionStorage SessionStorage
@inject WorkspaceService Workspace
@inject ResumeMatcherService Matcher

<p>Matcher loaded: @Matcher != null</p>

<h3>Upload Resume</h3>

@if (_isPrerendering)
{
    <p>Initializing resume upload...</p>
}
else
{
    <InputFile OnChange="HandleFileSelect" />

    @if (!string.IsNullOrEmpty(Workspace.Current.ResumeFileName))
    {
        <p><strong>Selected file:</strong> @Workspace.Current.ResumeFileName</p>
    }

    @if (!string.IsNullOrEmpty(Workspace.Current.ResumeText))
    {
        <h5 class="mt-3">Resume Preview:</h5>
        <pre>@Workspace.Current.ResumeText</pre>
    }
}

@code {
    private bool _isPrerendering = true;
    private bool hasLoadedSession = false;
    private const long MaxBinaryBytes = 10 * 1024 * 1024; // 10 MB

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _isPrerendering = false;
            StateHasChanged();
            return;
        }

        if (!_isPrerendering && !hasLoadedSession)
        {
            var resumeResult = await SessionStorage.GetAsync<string>("resumeText");
            var fileResult = await SessionStorage.GetAsync<string>("resumeFileName");

            Workspace.Current.ResumeText = resumeResult.Success && resumeResult.Value is not null
                ? resumeResult.Value
                : string.Empty;

            Workspace.Current.ResumeFileName = fileResult.Success && fileResult.Value is not null
                ? fileResult.Value
                : string.Empty;

            hasLoadedSession = true;
            StateHasChanged();
        }
    }

    private async Task HandleFileSelect(InputFileChangeEventArgs e)
    {
        var file = e.File;
        var fileName = file.Name;
        var ext = System.IO.Path.GetExtension(fileName).ToLowerInvariant();

        if (ext == ".pdf" || ext == ".docx")
        {
            // Upload to server for text extraction
            var content = new MultipartFormDataContent();
            var stream = file.OpenReadStream(MaxBinaryBytes);
            var sc = new StreamContent(stream);
            sc.Headers.ContentType = new System.Net.Http.Headers.MediaTypeHeaderValue(file.ContentType ?? "application/octet-stream");
            content.Add(sc, "file", fileName);

            var response = await Http.PostAsync("api/extract", content);
            if (response.IsSuccessStatusCode)
            {
                var payload = await response.Content.ReadFromJsonAsync<ExtractResult>();
                Workspace.SetFileName(payload?.fileName ?? fileName);
                Workspace.SetResume(payload?.preview ?? $"No text extracted from {fileName}");
                await SessionStorage.SetAsync("resumeFileName", Workspace.Current.ResumeFileName);
                await SessionStorage.SetAsync("resumeText", Workspace.Current.ResumeText);
            }
            else
            {
                Workspace.SetFileName(fileName);
                Workspace.SetResume($"Could not extract preview: {response.ReasonPhrase}");
            }
        }
        else
        {
            // As before: read known text types client-side
            using var reader = new System.IO.StreamReader(file.OpenReadStream(2 * 1024 * 1024), System.Text.Encoding.UTF8, true);
            var text = await reader.ReadToEndAsync();
            Workspace.SetResume(text);
            Workspace.SetFileName(fileName);
            await SessionStorage.SetAsync("resumeText", text);
            await SessionStorage.SetAsync("resumeFileName", fileName);
        }

        StateHasChanged();
    }

    private record ExtractResult(string preview, string fileName);
}
